#!/usr/bin/python3
# SPDX-License-Identifier: LGPL-3.0-or-later
# Copyright (C) 2022 Intel Corporation
#                    Sankaranarayanan Venkatasubramanian
#                        <sankaranarayanan.venkatasubramanian@intel.com>
#                    Borys Pop≈Çawski <borysp@invisiblethingslab.com>

import datetime
import hashlib
import os

import click

from graminelibos import (
    Manifest, get_tbssigstruct, SGX_LIBPAL, SGX_RSA_KEY_PATH,
)

def sign_with_akv(data, key):
    """Signs *data* using *key* from Azure Key Vault's Managed HSM.

    Function used to generate an RSA signature over provided data using a 3072-bit private key with
    the public exponent of 3 (hard Intel SGX requirement on the key size and the exponent).
    Suitable to be used as a callback to :py:func:`graminelibos.Sigstruct.sign()`. This function
    requires that the user has an active subscription to Azure and Azure Key Vault's Managed HSM
    (MHSM), a 3072-bit RSA key created in the MHSM enabled for signing and the user is logged into
    Azure CLI.

    Args:
        data (bytes): Data to calculate the signature over.
        key (str): Path to RSA private key in the AKV's Managed HSM in `vault_url:key_name` format.

    Returns:
        (int, int, int): Tuple of exponent, modulus and signature respectively.
    """

    from azure.identity import DefaultAzureCredential
    from azure.keyvault.keys import KeyClient
    from azure.keyvault.keys.crypto import CryptographyClient, SignatureAlgorithm

    key_details = key.rsplit(':', 1)
    vault_url = key_details[0]
    key_name = key_details[1]

    credential = DefaultAzureCredential(exclude_managed_identity_credential=True,
                                        exclude_visual_studio_code_credential=True,
                                        exclude_environment_credential=True,
                                        exclude_shared_token_cache_credential=True,
                                        exclude_powershell_credential=True)

    key_client = KeyClient(vault_url=vault_url, credential=credential)
    rsa_key = key_client.get_key(key_name)
    crypto_client = CryptographyClient(rsa_key, credential=credential)

    digest = hashlib.sha256(data).digest()
    result = crypto_client.sign(SignatureAlgorithm.rs256, digest)
    signature = result.signature

    exponent_int = int.from_bytes(rsa_key.key.e, byteorder='big')
    modulus_int = int.from_bytes(rsa_key.key.n, byteorder='big')
    signature_int = int.from_bytes(signature, byteorder='big')

    return exponent_int, modulus_int, signature_int


@click.command()
@click.option('--output', '-o', type=click.Path(), required=True,
              help='Output .manifest.sgx file (manifest augmented with autogenerated fields)')
@click.option('--libpal', '-l', type=click.Path(exists=True, dir_okay=False), default=SGX_LIBPAL,
              help='Input libpal file')
@click.option('--key', '-k', type=click.STRING, required=True,
              help='Signing key in format `vault_url:key_name` for AKV Managed HSM')
@click.option('--manifest', '-m', 'manifest_file', type=click.File('r', encoding='utf-8'),
              required=True, help='Input .manifest file')
@click.option('--sigfile', '-s', help='Output .sig file')
@click.option('--verbose/--quiet', '-v/-q', default=True, help='Display details (on by default)')
def main(output, libpal, key, manifest_file, sigfile, verbose):
    # pylint: disable=too-many-arguments

    manifest = Manifest.load(manifest_file)

    expanded = manifest.expand_all_trusted_files()

    with open(output, 'w', encoding='utf-8') as f:
        manifest.dump(f)

    if not sigfile:
        if manifest_file.name.endswith('.manifest'):
            sigfile = manifest_file.name[:-len('.manifest')]
        else:
            sigfile = manifest_file.name
        sigfile += '.sig'

    if verbose:
        print(f'Signing with key `{key}`.')

    today = datetime.date.today()
    sigstruct = get_tbssigstruct(output, today, libpal, verbose=verbose)
    sigstruct.sign(sign_with_akv, key)

    with open(sigfile, 'wb') as f:
        f.write(sigstruct.to_bytes())


if __name__ == '__main__':
    main() # pylint: disable=no-value-for-parameter
