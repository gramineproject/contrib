#!/usr/bin/python3
# SPDX-License-Identifier: LGPL-3.0-or-later
# Copyright (C) 2022 Intel Corporation
#                    Sankaranarayanan Venkatasubramanian
#                        <sankaranarayanan.venkatasubramanian@intel.com>
#                    Borys Pop≈Çawski <borysp@invisiblethingslab.com>

import datetime
import hashlib
import os
import subprocess

import click

from graminelibos import (
    Manifest, get_tbssigstruct, SGX_LIBPAL, SGX_RSA_KEY_PATH,
)

def sign_with_ossl_engine(data, engine, key):
    """Signs *data* using *key* from OpenSSL *engine*

    Function used to generate an RSA signature over provided data using a 3072-bit private key with
    the public exponent of 3 (hard Intel SGX requirement on the key size and the exponent).
    Suitable to be used as a callback to :py:func:`graminelibos.Sigstruct.sign()`. This function
    requires that a valid OpenSSL engine is installed/enabled, the user has access to the engine and
    a 3072-bit RSA key created in the engine that is enabled for signing. 

    Args:
        data (bytes): Data to calculate the signature over.
        engine (str): The openssl engine to use.
        key (str): Name/ID of RSA private key in the HSM.

    Returns:
        (int, int, int): Tuple of exponent, modulus and signature respectively.
    """

    proc = subprocess.Popen(
        ['openssl', 'rsa', '-engine', engine, '-modulus', '-in', key, '-inform', 'engine', '-noout'],
        stdout=subprocess.PIPE)
    modulus_out, _ = proc.communicate()
    modulus = bytes.fromhex(modulus_out[8:8+offs.SE_KEY_SIZE*2].decode())

    # Digest the data for signing
    digest = hashlib.sha256(data).digest()
    proc = subprocess.Popen(
            ['openssl', 'pkeyutl', '-engine', engine, '-sign', '-inkey', key, '-keyform', 'engine', '-pkeyopt', 'digest:sha256'],
            stdin=subprocess.PIPE, stdout=subprocess.PIPE)
    signature, _ = proc.communicate(digest)

    exponent_int = 3
    modulus_int = int.from_bytes(modulus, byteorder='big')
    signature_int = int.from_bytes(signature, byteorder='big')

    return exponent_int, modulus_int, signature_int

@click.command()
@click.option('--output', '-o', type=click.Path(), required=True,
              help='Output .manifest.sgx file (manifest augmented with autogenerated fields)')
@click.option('--libpal', '-l', type=click.Path(exists=True, dir_okay=False), default=SGX_LIBPAL,
              help='Input libpal file')
@click.option('--key', '-k', type=click.STRING, required=True,
              help='Signing key name in HSM managed through OpenSSL engine')
@click.option('--engine', '-e', type=click.STRING, required=True,
              help='OpenSSL engine to be used')
@click.option('--manifest', '-m', 'manifest_file', type=click.File('r', encoding='utf-8'),
              required=True, help='Input .manifest file')
@click.option('--sigfile', '-s', help='Output .sig file')
@click.option('--verbose/--quiet', '-v/-q', default=True, help='Display details (on by default)')
def main(output, libpal, key, engine, manifest_file, sigfile, verbose):
    # pylint: disable=too-many-arguments

    manifest = Manifest.load(manifest_file)

    expanded = manifest.expand_all_trusted_files()

    with open(output, 'wb') as f:
        manifest.dump(f)

    if not sigfile:
        if manifest_file.name.endswith('.manifest'):
            sigfile = manifest_file.name[:-len('.manifest')]
        else:
            sigfile = manifest_file.name
        sigfile += '.sig'

    if verbose:
        print(f'Signing with key `{key}` through OpenSSL engine `{engine}`.')

    today = datetime.date.today()
    sigstruct = get_tbssigstruct(output, today, libpal, verbose=verbose)
    sigstruct.sign(sign_with_ossl_engine, engine, key)

    with open(sigfile, 'wb') as f:
        f.write(sigstruct.to_bytes())


if __name__ == '__main__':
    main() # pylint: disable=no-value-for-parameter
